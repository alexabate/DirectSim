// -*- LSST-C++ -*-
#include "machdefs.h"
#include "sopnamsp.h"
#include <iostream>
#include <fstream>
#include <string>
#include <math.h>

#include <typeinfo>
#include "timing.h"

#include "array.h"
#include "hisprof.h"
#include "histerr.h"
#include "histinit.h"
#include "fiosinit.h"
#include "fitsioserver.h"
#include "fftwserver.h"
#include "mydefrg.h"
#include "resusage.h"
#include "timestamp.h"

#include "schechter.h"
#include "cosmocalcs.h"
#include "gftdist.h"
#include "simdata.h"
#define PI 3.141592
/*

	Test the magnitude simulation method.
	
	This code should be able to simulate GOODS WFI data
	(Great Observatories Origins Deep Survey - Wide Field Imager)

*/
void usage(void);
void usage(void)
{
	cout << endl<<" Usage: testgoodsmagsim [...options...]" << endl<<endl;
		
	cout << "  Test the magnitude simulation method." << endl<<endl;
	
	cout << "  This code should be able to simulate GOODS WFI data" << endl;
	cout << "  (Great Observatories Origins Deep Survey - Wide Field Imager)"<< endl;
	cout <<endl;

	cout << "  The simulation method is described briefly in Dahlen et al 2008,"<<endl;
	cout << "  section 2.  This program produces a mock galaxy catalog with the"<<endl;
	cout << "  following data: zs,BVRI,sedtype,absmag. Compare the resulting"<<endl;
	cout << "  catalog to:"<<endl;
	cout << "             (i) abs mag distribution to the B-band LFs in Dahlen "<<endl;
	cout << "                 et al 2005"<<endl;
	cout << "            (ii) number counts in B and R to the plots in Fig 3, in "<<endl;
 	cout << "                 Dahlen et al 2008"<<endl;
	cout << "           (iii) B-R color histogram to the plots in Fig 4 in Dahlen"<<endl;
	cout << "                 et al 2008"<<endl<<endl;

	cout << " -i : INFILE: input filename "<<endl;
	cout << " -o : OUTFILE: output filename "<<endl;
	cout << " -e : FLUXERR: photometric error (in % of flux) "<<endl;
	cout << endl;
}
int main(int narg, char* arg[])
{
	cout << " ==== testgoodsmagsim.cc program , to check absolute magnitude";
	cout << " simulation  ==== "<<endl;

	// make sure SOPHYA modules are initialized 
	SophyaInit();  
	FitsIOServerInit();
	InitTim();
	cout<<endl<<endl;

	//--- decoding command line arguments 
	string outfile="testfiles/testgoodsmagsim.fits";
	string infile="testfiles/testbasesim.fits";
	double fluxError=0.;
  
	//--- decoding command line arguments 
	cout << " ==== decoding command line arguments ===="<<endl;
	char c;
	while((c = getopt(narg,arg,"ho:e:i:")) != -1) 
	{
	switch (c) 
		{
	  case 'i' :
		infile = optarg;
		break;
	  case 'o' :
		outfile = optarg;
		break;
	  case 'e' :
		sscanf(optarg,"%lf",&fluxError);
		break;
	  case 'h' :
		default :
		usage(); return -1;
		}
	}
  cout << "     Input filename is "<<infile<<endl;
  cout << "     Output filename is "<<outfile<<endl;
  cout << "     Magnitude error = "<<fluxError<<endl;
  //-- end command line arguments
  
  int rc = 1;  
  try {  // exception handling try bloc at top level
	ResourceUsage res;
	InitTim();
	
	// this controls the drawing of random numbers
	RandomGenerator rg;

	// Set cosmology
	double h=0.7, OmegaM=0.3, OmegaL=0.7;
	SimpleUniverse su(h,OmegaM,OmegaL);
	su.SetFlatUniverse_OmegaMatter();
	cout <<"     Set cosmology to: OmegaM="<<OmegaM<<", OmegaL="<<OmegaL;
	cout <<", H0="<<100*h<<endl;
	cout << endl;

	// Read in catalog generated by testbasesim
	// Contains basic galaxy properties: redshift, absolute magnitude, 
	// broad type (elliptical, spiral, starburst), 
	FitsInOutFile fin(infile,FitsInOutFile::Fits_RO);
	fin.MoveAbsToHDU(2);
	SwFitsDataTable dt(fin,512,false);
	sa_size_t ng=dt.NEntry();
	sa_size_t nc=dt.NCols();
	DataTableRow row=dt.EmptyRow();
	cout <<"     In file "<<infile<<" ... "<<endl;
	cout <<"     Number of columns = "<<nc<<", number of entries = "<<ng;
	cout << endl;

	// Output file
	cout <<"     Creating output file "<<outfile<<endl;
	FitsInOutFile swf(outfile,FitsInOutFile::Fits_Create);
	SwFitsDataTable gals(swf,2048);
	gals.AddFloatColumn("zs");
	gals.AddFloatColumn("am");
	gals.AddFloatColumn("type");
	gals.AddFloatColumn("ext");
	gals.AddFloatColumn("mU");
	gals.AddFloatColumn("mB");
	gals.AddFloatColumn("mV");
	gals.AddFloatColumn("mR");
	gals.AddFloatColumn("mI");
	gals.AddFloatColumn("mUo");
	gals.AddFloatColumn("mBo");
	gals.AddFloatColumn("mVo");
	gals.AddFloatColumn("mRo");
	gals.AddFloatColumn("mIo");
	gals.AddFloatColumn("emU");
	gals.AddFloatColumn("emB");
	gals.AddFloatColumn("emV");
	gals.AddFloatColumn("emR");
	gals.AddFloatColumn("emI");
	DataTableRow rowin=gals.EmptyRow();
	cout << endl;

	// Load in filters required
	// wavelength range of the SEDs/filters
	cout <<"     Load in GOODS filters"<<endl;
	double lmin=5e-8, lmax=2.5e-6;
	string goodsFilterFile = "GOODS.filters";
	ReadFilterList readGOODSfilters(goodsFilterFile);
	readGOODSfilters.readFilters(lmin,lmax);
	vector<Filter*> GOODSfilters=readGOODSfilters.getFilterArray();
	int nGOODS=readGOODSfilters.getNTot();
	cout <<"     Read in "<< nGOODS <<" filters"<<endl;
	//Filter restFrameFilter((*GOODSfilters[1]));
	int iU = 0;
	int iB = 1;
	int iV = 2;
	int iR = 3;
	int iI = 4;
	cout <<endl;
	
	// Load in SEDs
	string sedFile = "CWWK.list";
	ReadSedList readSedList(sedFile);
    readSedList.readSeds(lmin,lmax); // Read out SEDs into array
    int nsed=readSedList.getNSed(); // Get total number of SEDs
    cout <<"     Number of original SEDs = "<<nsed<<endl;
	cout << endl;
	
	// Interpolate SEDs
	int nInterp = 2; 
	readSedList.interpSeds(nInterp);
    cout <<"     Interpolated SEDs "<<nInterp<<" times "<<endl;
    int ntot = readSedList.getNTot();
    cout <<"     Total number of SEDs now = "<<ntot<<endl;
	cout << endl;
	
    // Reorder SEDs and return them
    readSedList.reorderSEDs();
    vector<SED*> sedArray=readSedList.getSedArray();
    int nElliptical = 3;
    int nSpiral = 6;
    cout <<endl;

	// Prepare the class which will calculate the magnitudes
	cout <<"     Initialize class to calculate magnitudes"<<endl;
	SimData simgal(sedArray,GOODSfilters,su,rg,nElliptical,nSpiral);
    cout << endl;

    // Loop over all galaxies in the base catalog
	cout <<"     Start loop over galaxies ..."<<endl;
	for (int i=0; i<ng; i++)
		{
		cout <<"     gal "<<i+1<<" of "<<ng<<endl;
		dt.GetRow(i,row);
		
		// Get galaxy properties: galaxy has redshift zs, absolute magnitude am,
		// SED type type and internal extinction ext.
		double zs=row[0];
		double am=row[1];
		int typ=(int)row[2];
		double type=simgal.SimSED(typ);
		double ext=simgal.SimRed(type);

        // Calculate galaxy magnitude in observed filters iU, iB, iV, iR, iI
        // Galaxy's absolute magnitude is defined in filter (*GOODSfilters[iB])
		double uMagTh=simgal.GetMag(zs,type,am,ext,iU,(*GOODSfilters[iB]));
		double bMagTh=simgal.GetMag(zs,type,am,ext,iB,(*GOODSfilters[iB]));
		double vMagTh=simgal.GetMag(zs,type,am,ext,iV,(*GOODSfilters[iB]));
		double rMagTh=simgal.GetMag(zs,type,am,ext,iR,(*GOODSfilters[iB]));
		double iMagTh=simgal.GetMag(zs,type,am,ext,iI,(*GOODSfilters[iB]));
		
		// The final observations
		// The 1st element is the value of the observed magnitude
		// The 2nd element is the magnitude error
		vector<double> uObservation = simgal.addError(uMagTh,fluxError,0);
		vector<double> bObservation = simgal.addError(bMagTh,fluxError,1);
		vector<double> vObservation = simgal.addError(vMagTh,fluxError,2);
		vector<double> rObservation = simgal.addError(rMagTh,fluxError,3);
		vector<double> iObservation = simgal.addError(iMagTh,fluxError,4);

        // Write the data to the FITS file
		rowin[0]=zs;
		rowin[1]=am;
		rowin[2]=type;
		rowin[3]=ext;
		rowin[4]=uMagTh;
		rowin[5]=bMagTh;
		rowin[6]=vMagTh;
		rowin[7]=rMagTh;
		rowin[8]=iMagTh;
		rowin[9]=uObservation[0];
		rowin[10]=bObservation[0];
		rowin[11]=vObservation[0];
		rowin[12]=rObservation[0];
		rowin[13]=iObservation[0];
		rowin[14]=uObservation[1];
		rowin[15]=bObservation[1];
		rowin[16]=vObservation[1];
		rowin[17]=rObservation[1];
		rowin[18]=iObservation[1];
		gals.AddRow(rowin);
		}
	cout <<"     End loop"<<endl;
	
	
	}  // End of try bloc 
  
  
  catch (PThrowable & exc) {  // catching SOPHYA exceptions
    cerr << " testgoodsmagsim.cc: Catched Exception (PThrowable)" 
	 << (string)typeid(exc).name() 
         << "\n...exc.Msg= " << exc.Msg() << endl;
    rc = 99;
  }
  catch (std::exception & e) {  // catching standard C++ exceptions
    cerr << " testgoodsmagsim.cc: Catched std::exception "  << " - what()= " 
	 << e.what() << endl;
    rc = 98;
  }
  catch (...) {  // catching other exceptions
    cerr << " testgoodsmagsim.cc: some other exception (...) was caught ! " 
	 << endl;
    rc = 97;
  }
  cout << " ==== End of testgoodsmagsim.cc program  Rc= " << rc << endl;
  return rc;	
}
